<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>贪吃蛇游戏</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
   body {
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  /* 背景图片 + 兜底颜色 */
  background: #ffeedd url("bg.jpg") center center / cover no-repeat fixed;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: #f5f5f5;
}
    .container {
      background: rgba(20, 20, 20, 0.7);
      padding: 20px 24px 18px;
      border-radius: 16px;
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      max-width: 520px;
      width: 100%;
    }
    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .title {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #fefefe;
    }
    .subtitle {
      font-size: 12px;
      opacity: 0.7;
    }
    .scoreboard {
      display: flex;
      gap: 12px;
      font-size: 13px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .scoreboard span {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .score-label {
      opacity: 0.7;
      margin-right: 4px;
    }

    canvas {
      display: block;
      background: #111;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin: 0 auto;
      touch-action: none;
    }

    .hint {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.6;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(76, 175, 80, 0.08);
      border: 1px solid rgba(76, 175, 80, 0.4);
      color: #a5d6a7;
      white-space: nowrap;
    }

    /* 方向按键区域 */
    .controls-wrapper {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      justify-content: center;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px 60px;
      gap: 6px;
      justify-content: center;
    }

    .ctrl-btn {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: radial-gradient(circle at top, #444 0, #222 70%);
      color: #f5f5f5;
      font-size: 22px;
      cursor: pointer;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      box-shadow:
        0 3px 6px rgba(0, 0, 0, 0.6),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      transition: transform 0.07s ease, box-shadow 0.07s ease, background 0.1s ease;
    }
    .ctrl-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow:
        0 1px 2px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(255, 255, 255, 0.04);
      background: radial-gradient(circle at bottom, #555 0, #222 80%);
    }

    /* 方向键布局：中间是空的 */
    .controls-grid .blank {
      background: transparent;
      border: none;
      box-shadow: none;
      pointer-events: none;
    }

    /* 重新开始按钮 */
    .restart-btn {
      margin-top: 4px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(76, 175, 80, 0.6);
      background: radial-gradient(circle at top, #4caf50 0, #1b5e20 70%);
      color: #e8f5e9;
      font-size: 14px;
      cursor: pointer;
      outline: none;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      box-shadow:
        0 4px 10px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      transition: transform 0.07s ease, box-shadow 0.07s ease, background 0.1s ease;
    }
    .restart-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow:
        0 2px 4px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      background: radial-gradient(circle at bottom, #66bb6a 0, #1b5e20 80%);
    }

    @media (max-width: 600px) {
      .container {
        padding: 16px;
      }
      .controls-grid {
        grid-template-columns: 54px 54px 54px;
        grid-template-rows: 54px 54px 54px;
        gap: 5px;
      }
      .ctrl-btn {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div>
        <div class="title">Snake</div>
        <div class="subtitle">经典贪吃蛇 · 方向键或按键控制</div>
      </div>
      <div class="badge">空格或按钮重新开始</div>
    </div>

    <div class="scoreboard">
      <span><span class="score-label">分数</span><span id="score">0</span></span>
      <span><span class="score-label">最高分</span><span id="highScore">0</span></span>
      <span><span class="score-label">速度</span><span id="speed">中等</span></span>
    </div>

    <canvas id="game" width="400" height="400"></canvas>

    <!-- 新增：方向按键 + 重新开始按钮 -->
    <div class="controls-wrapper">
      <div class="controls-grid">
        <button class="ctrl-btn blank"></button>
        <button class="ctrl-btn" id="btnUp">▲</button>
        <button class="ctrl-btn blank"></button>

        <button class="ctrl-btn" id="btnLeft">◀</button>
        <button class="ctrl-btn blank"></button>
        <button class="ctrl-btn" id="btnRight">▶</button>

        <button class="ctrl-btn blank"></button>
        <button class="ctrl-btn" id="btnDown">▼</button>
        <button class="ctrl-btn blank"></button>
      </div>

      <button class="restart-btn" id="btnRestart">重新开始</button>
    </div>

    <div class="hint">
      <span>键盘 ↑ ↓ ← → 或下方箭头按钮控制方向</span>
      <span>吃到食物加分，碰到墙或自己会失败</span>
    </div>
  </div>

  <script>
    // 基础设置
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const tileCount = 20;
    const tileSize = canvas.width / tileCount;

    let snake = [];
    let direction = { x: 1, y: 0 };   // 初始向右
    let food = { x: 10, y: 10 };
    let score = 0;
    let highScore = Number(localStorage.getItem("snake_high_score") || 0);
    let gameOver = false;
    let gameLoopId = null;

    const scoreEl = document.getElementById("score");
    const highScoreEl = document.getElementById("highScore");
    const speedEl = document.getElementById("speed");

    const btnUp = document.getElementById("btnUp");
    const btnDown = document.getElementById("btnDown");
    const btnLeft = document.getElementById("btnLeft");
    const btnRight = document.getElementById("btnRight");
    const btnRestart = document.getElementById("btnRestart");

    // 难度影响速度：简单/中等/困难
    const speedLevels = {
      easy: 180,
      medium: 120,
      hard: 80,
    };
    let currentSpeed = "medium";

    highScoreEl.textContent = highScore;

    function updateSpeedText() {
      speedEl.textContent =
        currentSpeed === "easy" ? "简单" :
        currentSpeed === "hard" ? "困难" : "中等";
    }

    function resetGame() {
      snake = [
        { x: 8, y: 10 },
        { x: 7, y: 10 },
        { x: 6, y: 10 },
      ];
      direction = { x: 1, y: 0 };
      score = 0;
      gameOver = false;
      scoreEl.textContent = "0";
      updateSpeedText();
      spawnFood();

      if (gameLoopId) {
        clearInterval(gameLoopId);
      }
      gameLoopId = setInterval(gameLoop, speedLevels[currentSpeed]);
      draw();
    }

    function spawnFood() {
      let newFood;
      while (true) {
        newFood = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount),
        };
        const onSnake = snake.some(seg => seg.x === newFood.x && seg.y === newFood.y);
        if (!onSnake) break;
      }
      food = newFood;
    }

    function gameLoop() {
      if (gameOver) return;
      update();
      draw();
    }

    function update() {
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y,
      };

      // 碰墙
      if (
        head.x < 0 ||
        head.x >= tileCount ||
        head.y < 0 ||
        head.y >= tileCount
      ) {
        endGame();
        return;
      }

      // 碰自己
      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // 吃到食物
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        if (score > highScore) {
          highScore = score;
          highScoreEl.textContent = highScore;
          localStorage.setItem("snake_high_score", highScore);
        }
        spawnFood();
        maybeIncreaseSpeed();
      } else {
        snake.pop();
      }
    }

    function maybeIncreaseSpeed() {
      if (score >= 80 && currentSpeed !== "hard") {
        currentSpeed = "hard";
        resetInterval();
      } else if (score >= 30 && currentSpeed === "easy") {
        currentSpeed = "medium";
        resetInterval();
      } else if (score >= 40 && currentSpeed === "medium") {
        currentSpeed = "hard";
        resetInterval();
      }
    }

    function resetInterval() {
      updateSpeedText();
      clearInterval(gameLoopId);
      gameLoopId = setInterval(gameLoop, speedLevels[currentSpeed]);
    }

    function drawGrid() {
      ctx.fillStyle = "#101010";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let x = 0; x < tileCount; x++) {
        for (let y = 0; y < tileCount; y++) {
          const isDark = (x + y) % 2 === 0;
          ctx.fillStyle = isDark ? "#151515" : "#111111";
          ctx.fillRect(
            x * tileSize,
            y * tileSize,
            tileSize,
            tileSize
          );
        }
      }
    }

    function drawSnake() {
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        const isHead = i === 0;
        const gradient = ctx.createRadialGradient(
          seg.x * tileSize + tileSize * 0.3,
          seg.y * tileSize + tileSize * 0.3,
          2,
          seg.x * tileSize + tileSize / 2,
          seg.y * tileSize + tileSize / 2,
          tileSize
        );
        if (isHead) {
          gradient.addColorStop(0, "#e8f5e9");
          gradient.addColorStop(1, "#66bb6a");
        } else {
          gradient.addColorStop(0, "#a5d6a7");
          gradient.addColorStop(1, "#2e7d32");
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(
          seg.x * tileSize + 1,
          seg.y * tileSize + 1,
          tileSize - 2,
          tileSize - 2
        );

        if (isHead) {
          ctx.fillStyle = "#111";
          const eyeSize = tileSize * 0.12;
          const offsetX = direction.x === 1 ? tileSize * 0.2 :
                          direction.x === -1 ? tileSize * 0.6 : tileSize * 0.25;
          const offsetYtop = direction.y === 1 ? tileSize * 0.2 :
                             direction.y === -1 ? tileSize * 0.6 : tileSize * 0.25;
          const offsetYbottom = offsetYtop + tileSize * 0.3;

          ctx.beginPath();
          ctx.arc(
            seg.x * tileSize + offsetX,
            seg.y * tileSize + offsetYtop,
            eyeSize,
            0,
            Math.PI * 2
          );
          ctx.fill();

          ctx.beginPath();
          ctx.arc(
            seg.x * tileSize + offsetX,
            seg.y * tileSize + offsetYbottom,
            eyeSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }
    }

   function drawFood() {
  const centerX = food.x * tileSize + tileSize / 2;
  const centerY = food.y * tileSize + tileSize / 2;

  // 外层饼皮（浅棕色）
  const crustGradient = ctx.createRadialGradient(
    centerX - tileSize * 0.1,
    centerY - tileSize * 0.1,
    2,
    centerX,
    centerY,
    tileSize * 0.45
  );
  crustGradient.addColorStop(0, "#f6d4a4"); // 亮一点
  crustGradient.addColorStop(1, "#c68b3a"); // 深一点
  ctx.fillStyle = crustGradient;
  ctx.beginPath();
  ctx.arc(centerX, centerY, tileSize * 0.45, 0, Math.PI * 2);
  ctx.fill();

  // 内层蛋挞心（蛋黄）
  const custardGradient = ctx.createRadialGradient(
    centerX - tileSize * 0.05,
    centerY - tileSize * 0.05,
    2,
    centerX,
    centerY,
    tileSize * 0.3
  );
  custardGradient.addColorStop(0, "#fff9c4");
  custardGradient.addColorStop(1, "#ffeb3b");
  ctx.fillStyle = custardGradient;
  ctx.beginPath();
  ctx.arc(centerX, centerY, tileSize * 0.3, 0, Math.PI * 2);
  ctx.fill();

  // 表面稍微烤焦的斑点
  ctx.fillStyle = "rgba(198,120,36,0.9)";
  ctx.beginPath();
  ctx.arc(centerX - tileSize * 0.08, centerY - tileSize * 0.05, tileSize * 0.06, 0, Math.PI * 2);
  ctx.arc(centerX + tileSize * 0.06, centerY + tileSize * 0.02, tileSize * 0.05, 0, Math.PI * 2);
  ctx.fill();

  // 右上高光
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.beginPath();
  ctx.arc(
    centerX + tileSize * 0.12,
    centerY - tileSize * 0.12,
    tileSize * 0.07,
    0,
    Math.PI * 2
  );
  ctx.fill();
}
    function drawGameOver() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#ff5252";
      ctx.font = "bold 32px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI'";
      ctx.textAlign = "center";
      ctx.fillText("游戏结束", canvas.width / 2, canvas.height / 2 - 10);

      ctx.fillStyle = "#f5f5f5";
      ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI'";
      ctx.fillText("按空格或点击“重新开始”", canvas.width / 2, canvas.height / 2 + 22);
    }

    function draw() {
      drawGrid();
      drawSnake();
      drawFood();
      if (gameOver) {
        drawGameOver();
      }
    }

    function endGame() {
      gameOver = true;
      clearInterval(gameLoopId);
      draw();
    }

    // 统一的改方向函数：避免直接反向
    function setDirection(newDir) {
      if (gameOver) return;
      // 避免 180 度掉头
      if (newDir.x === -direction.x && newDir.y === -direction.y) return;
      direction = newDir;
    }

    // 键盘控制
    window.addEventListener("keydown", e => {
      const key = e.key;
      if (key === "ArrowUp") {
        setDirection({ x: 0, y: -1 });
      } else if (key === "ArrowDown") {
        setDirection({ x: 0, y: 1 });
      } else if (key === "ArrowLeft") {
        setDirection({ x: -1, y: 0 });
      } else if (key === "ArrowRight") {
        setDirection({ x: 1, y: 0 });
      } else if (key === " " || key === "Spacebar") {
        resetGame();
      }
    });

    // 按钮控制（鼠标 + 手机点按）
    function addButtonControl(btn, dir) {
      if (!btn) return;
      btn.addEventListener("click", () => {
        setDirection(dir);
      });
    }

    addButtonControl(btnUp,    { x: 0,  y: -1 });
    addButtonControl(btnDown,  { x: 0,  y: 1 });
    addButtonControl(btnLeft,  { x: -1, y: 0 });
    addButtonControl(btnRight, { x: 1,  y: 0 });

    if (btnRestart) {
      btnRestart.addEventListener("click", () => {
        resetGame();
      });
    }

    // 初始化
    updateSpeedText();
    resetGame();
  </script>
</body>
</html>


